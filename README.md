# Pattern-Recognition-and-Machine-Learning
Αναγνώριση Προτύπων και Μηχανική Μάθηση

ΘΕΜΑ 1. Υλοποίηση αλγορίθμων ιεραρχικής ομαδοποίησης δεδομένων και εφαρμογή τους στα δεδομένα εκφράσεων προσώπου.

Η διαδικασία της ιεραρχικής ομαδοποίησης περιγράφεται από τον εξής αλγόριθμο:
1. Καταχώρηση κάθε ενός από τα Ν στοιχεία σε μία μοναδική ομάδα, με αποτέλεσμα τη δημιουργία Ν ομάδων.
2. Εύρεση των στοιχείων ή ομάδων με τη μεγαλύτερη ομοιότητα μεταξύ τους και συγχώνευση σε μία νέα ομάδα.
3. Επανάληψη του δεύτερου βήματος έως ότου όλα τα στοιχεία κατηγοριοποιηθούν στην ίδια ομάδα.

Στο πρόβλημα αυτό, έχουν παρασχεθεί δεδομένα που αντιστοιχούν στις μετρήσεις δύο χαρακτηριστικών που έγιναν σε 83 άτομα για τρεις διαφορετικές εκφράσεις προσώπου (χαράς, ουδέτερης έκφρασης και έκπληξης) οι οποίες περιέχονται στο αρχείο “features.xls”. Για τη λύση του προβλήματος, υλοποιήσαμε κώδικα σε Matlab. Όταν εξάγουμε τα δεδομένα με τη χρήση Matlab, αυτά έχουν τη μορφή ενός πίνακα 6x83, όπου για κάθε άτομο έχουμε τρεις τιμές, για κάθε ένα από τα δύο χαρακτηριστικά. Με τις κατάλληλες μετατροπές, ο πίνακας αυτός μετασχηματίζεται σε έναν πίνακα 249x2 όπου σε κάθε γραμμή του πίνακα έχουμε τις τιμές των δύο χαρακτηριστικών. Κατ’ αυτόν τον τρόπο εξαλείφεται η φυσική ομαδοποίηση που υπήρχε μεταξύ των τριών εκφράσεων του προσώπου στον τρόπο που ήταν αποθηκευμένα τα δεδομένα στον πίνακα.

Δοκιμάσαμε διάφορες συναρτήσεις μετρικής καθώς και διάφορους τύπους ομαδοποίησης με παρόμοια αποτελέσματα αλλά καταλήξαμε στη χρήση της Ευκλείδειας Απόστασης και της μεθόδου ομαδοποίησης “average” περιγράφοντας την “unweighted average distance”, με την οποία επιτυγχάνεται καλύτερη προσέγγιση από άποψη βέλτιστης και συνάμα ικανοποιητικότερης ομαδοποίησης.


ΘΕΜΑ 2. Εφαρμογή Γενετικού Αλγορίθμου Προβλήματος του Περιοδεύοντος Πωλητή (Αποτελέσματα αναζήτησης Αποτελέσματα ιστού (Traveling Salesman Problem (TSP) Genetic Algorithm Implementation)

Αν υποθέσουμε λοιπόν ότι έχουμε 50 πόλεις, οι πιθανές διαδρομές σε περίπτωση χρήσης κλασικού αλγορίθμου θα ήταν περίπου 50! (δηλαδή 3.04140932e64) υπολογισμοί για να βρεθεί η ελάχιστη διαδρομή, ενώ μέσω χρήσης γενετικών εξελικτικών αλγορίθμων θα χρειαστούμε μόλις 3486 επαναλήψεις. Οι εξελικτικοί αλγόριθμοι (evolutionary algorithms) δεν επιχειρούν να εντοπίσουν την καλύτερη λύση, αλλά ξεκινώντας από έναν αρχικό πληθυσμό λύσεων, παράγουν νέες γενιές λύσεων, καλύτερες από τις προηγούμενες.

Σε γενικές γραμμές και με απλά λόγια οι γενετικοί αλγόριθμοι είναι χρήσιμοι όταν:

1. Γνωρίζουμε τι έχουμε
2. Γνωρίζουμε που θέλουμε να φτάσουμε
3. Δεν γνωρίζουμε ή γνωρίζουμε λίγα για όλα τα ενδιάμεσα

Προβλήματα που δεν λύνονται (ή είναι πολύ δύσκολο και χρονοβόρο να λυθούν) με κλασικούς αλγόριθμους είναι τα μη πολυωνυμικά προβλήματα, δηλαδή τα προβλήματα όπου είναι δυνατή η αναζήτηση μιας προσεγγιστικής λύσης που δεν είναι απαραίτητα η βέλτιστη σε πολυωνυμικό χρόνο. Αυτά τα προβλήματα έχουν συνήθως έναν απλό, αλλά πολύ αργό αλγόριθμο O(2^n), του οποίου η χρήση είναι απαγορευτική όταν το εύρος λύσεων είναι μεγάλο. Το παρόν πρόβλημα του περιοδεύοντος πωλητή είναι ένα χαρακτηριστικό μη πολυωνυμικό πρόβλημα.

Ο παρών κώδικας δεν ακολουθεί την αυστηρή δομή και φιλοσοφία των γενετικών αλγορίθμων (επιλογή, διασταύρωση, μετάλλαξη), διότι δεν χρησιμοποιεί πουθενά την μέθοδο crossover (διασταύρωση), αλλά παρόλα αυτά παραμένει Γ.Α και δίνει μία πολύ καλή προσεγγιστικά και γρήγορη λύση στο πρόβλημα.

Ο λόγος που δεν χρησιμοποιείται η crossover είναι διότι, οι τελεστές θα λειτουργούσαν εν τέλει καταστροφικά κάνοντας υπερβολικά μεγάλες αλλαγές στις ανά γενεά διαδρομές. Αντ’ αυτού ο δημιουργός προτιμά τρεις διαφορετικές μεθόδους μετάλλαξης.

Συγκεκριμένα, η λογική του κώδικα, καθώς και οι mutation τελεστές που χρησιμοποιούνται έχουν ως εξής: (βλ. % Χειριστές των Γενετικού Αλγορίθμου (Βήμα 3) στον παρόντα κώδικα).

Στο πρώτο for του εν λόγω σημείου ομαδοποιούνται αρχικά ομάδες των τεσσάρων διαδρομών, εκ των οποίων κρατάει την καλύτερη διαδρομή από τις τέσσερις αυτές και την περνάει στη νέα γενεά. Στο δεύτερο for πραγματοποιούνται τρεις μεταλλάξεις (Flip, Swap, Slide) σ’ αυτήν την «καλύτερη διαδρομή» με αποτέλεσμα να δημιουργηθούν τρεις ακόμη μεταλλαγμένες διαδρομές οι οποίες (μαζί με την κανονική «καλύτερη») περνάνε επίσης στην επόμενη γενεά.

Έτσι, στην επόμενη γενεά, θα έχουμε νέες ομάδες των τεσσάρων διαδρομών, εκ των οποίων πάλι θα επιλεχθεί η καλύτερη η οποία θα επαναμεταλλαχθεί κοκ. Η διαδικασία θα επαναλαμβάνεται μέχρι να επιτευχθεί ένα ικανοποιητικό αποτέλεσμα, το οποίο δεν θα μικραίνει ιδιαίτερα ή θα παραμένει σταθερό μετά από κάποια επανάληψη και έπειτα. Αξιοσημείωτο είναι το φαινόμενο του ελιτισμού που παρατηρείται, εφόσον επιλεκτικά διατηρούνται προς αναπαραγωγή οι δυνατότεροι απόγονοι και ο αλγόριθμος δεν αφήνεται πλήρως στην τυχαιότητα.

Ο υλοποιημένος γενετικός κώδικας που μελετάται και παρατίθεται στη συνέχεια υπάρχει διαθέσιμος στο: http://www.mathworks.com/matlabcentral/fileexchange/13680.

Ως εισόδους δέχεται:

XY (float): είναι ένας πίνακας Νx2 με τοποθεσίες πόλεων, όπου Ν ο αριθμός των πόλεων

DMAT (float): είναι ένας πίνακας ΝxΝ με αποστάσεις/κόστη από σημείο σε σημείο

POPSIZE (scalar integer): είναι το μέγεθος του πληθυσμού

1. Πρέπει να διαιρείται με το 4 λόγω του τρόπου με τον οποίο οι καλές λύσεις στο συγκεκριμένο πληθυσμό αναπαράγονται στην επόμενη γενεά λύσεων.
2. Από τον πληθυσμό ομαδοποιούνται τυχαία κάθε φορά ανά τέσσερις οι πιθανές λύσεις, λαμβάνεται η καλύτερη από αυτές τις τέσσερις και προωθείται ακέραια στην επόμενη γενεά.
3. Έπειτα εκτελούνται τρεις διαφορετικές μεταλλάξεις σ’ αυτή την καλύτερη από τις τέσσερις λύσεις, και προωθούνται οι μεταλλαγμένες εκδοχές στην επόμενη γενεά.

NUMITER (scalar integer): είναι ο αριθμός των επαναλήψεων για τις οποίες θέλουμε να τρέξει το πρόγραμμα

SHOWPROG (scalar logical): δείχνει την πρόοδο του γενετικού αλγορίθμου αν είναι αληθής

SHOWRESULT (scalar logical): δείχνει τα αποτελέσματα του γενετικού αλγορίθμου αν είναι αληθής

Ως εξόδους δίνει:

OPTROUTE (integer array): είναι η καλύτερη διαδρομή που βρέθηκε από τον αλγόριθμο
MINDIST (scalar float): είναι το κόστος της καλύτερης διαδρομής

Στα παραρτήματα θα δείτε και έναν άλλο διαφορετικό υλοποιημένο γενετικό αλγόριθμο ο οποίος λειτουργεί με τον ίδιο ακριβώς τρόπο, λαμβάνοντας παρόμοια με τα παρακάτω αποτελέσματα.


ΘΕΜΑ 3. Διαβάστε το αρχείο Stock Market Prediction